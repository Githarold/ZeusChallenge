import open3d as o3d    
from math import cos, sin, pi
import numpy as np
from cmath import nan, sqrt
# import cv2

class ICP:
        def __init__(self):
              self.R = np.eye(3)
              self.t = np.array([0,0,0])

        def doICP(self, src, tar):
                '''
                src : camera to object
                tar : gripper to object

                => gripper to camera가 결과로 나옴
                '''


                # trans_init = np.asarray([[1.0, 0.0, 0.0, 0.0], 
                #                          [0.0, 1.0, 0.0, 90.0],
                #                          [0.0, 0.0, 1.0, 345.0],
                #                         [0.0, 0.0, 0.0, 1.0]], float)
                # trans_init = np.asarray([[0.  , 1.  , 0. , -105.],
                #         [ -1. ,  0.  , 0. , 0.],
                #          [0. ,  0.  , 1., -345.],
                #          [0.  , 0.  , 0.  , 1.]],float)


                # 우리가 최종적으로 썼던 최종 값
                # trans_init = np.asarray([[0.  , 1.  , 0. , -105./1000],
                #         [ -1. ,  0.  , 0. , 0.],
                #          [0. ,  0.  , 1., -345/1000],
                #          [0.  , 0.  , 0.  , 1.]],float)


                # 초기값은 이렇게 줘도 참값이 나온다!
                trans_init = np.asarray(
                        [[1.  , 0.  , 0. , 0.],
                        [ 0. ,  1.  , 0. , 0.],
                        [0. ,  0.  , 1., 0.],
                        [0.  , 0.  , 0.  , 1.]],float)


                # 1000 : 쓰레쉬 홀드, 바꾸지 않아도 결과 잘 자옴
                # max_iteration : 반복 횟수
                reg_p2p = o3d.pipelines.registration.registration_icp(
                                src, tar, 1000., trans_init,
                                o3d.pipelines.registration.TransformationEstimationPointToPoint(),
                                o3d.pipelines.registration.ICPConvergenceCriteria(relative_fitness=1.0e-6, relative_rmse=1.0e-6, max_iteration=100000000))


                # 해당 결과 값에 translation 부분에 1000을 곱해준다. => robot의 단위는 mm, 캘리브레이션 결과 m단위 이므로 단위를 맞춰 줘야 한다. 
                print("Transformation is:")
                print(reg_p2p.transformation)           # gripper to camera
                self.R = reg_p2p.transformation[:3,:3]
                self.t = reg_p2p.transformation[:3,3]
                print("\n")
                print("Inverse is:")
                print(np.linalg.inv(reg_p2p.transformation))

                # o3d 따로 색지정 해주는 것, 노란색이 camera to object, 파란색이 gripper to camera
                src.paint_uniform_color([1, 0.706, 0])
                tar.paint_uniform_color([0, 0.651, 0.929])

                temp = src.transform(reg_p2p.transformation)

                # o3d 상에서 좌표축 추가
                mesh_frame = o3d.geometry.TriangleMesh.create_coordinate_frame(size=0.1, origin=[0, 0, 0])

                o3d.visualization.draw_geometries([temp, tar, mesh_frame])
        
        # calibration.py와 calibration_icp_2와는 차이가 좀 있음!!
        def cal_error(self,a1, a2):
                sum_of_error = 0
                err2 = 0
                print(self.t)
                for num in range(0, a1.shape[0]):
                        err2 = sqrt(((a1[num].dot(self.R) + self.t - a2[num]) ** 2).sum())

                        # print(a1[num].shape)
                        # print(a1[num].dot(self.R).shape)
                        # print("Test Residual error", num + 1, err2)
                        sum_of_error += err2
                        # print("-"*10)
                        # print(a1[num].dot(self.R) + self.t ) ##a3: camera
                        # print(a2[num]) #a4: base to tool
                        # print("-"*10)

                print("-"*10)
                # print(a1.shape[0])
                print("mean of error ", sum_of_error/a1.shape[0] *1000 , "mm")

  

        


class calibration():

    # camera to object
    def icp(self):
        a1 = np.array([  
        
[ 0.0175020 , 0.0192009 , 0.3260000 ],
####################################
[ -0.0221525 , 0.0219102 , 0.3720000 ],
#####################################
[ -0.0258913 , 0.0429563 , 0.4790000 ],
#####################################
[ 0.0418519 , 0.0637820 , 0.5020000 ],
#####################################
[ 0.0541009 , 0.0090676 , 0.4440000 ],
#####################################
[ -0.0013075 , -0.0032725 , 0.5490000 ],
#####################################
[ 0.0113466 , -0.0020617 , 0.5480000 ],
#####################################
[ -0.0130400 , 0.0121449 , 0.5120000 ],
#####################################
[ 0.0322885 , 0.0475965 , 0.4530000 ],
#####################################
[ 0.0177426 , 0.0259971 , 0.4770000 ],
#####################################
[ 0.1936524 , 0.0269324 , 0.4750000 ],
#####################################
[ 0.0123624 , -0.0028523 , 0.4040000 ],
#####################################
[ -0.0994204 , 0.0038402 , 0.4610000 ],
#####################################
[ -0.1568074 , -0.0244206 , 0.4320000 ],
#####################################
[ -0.0634473 , -0.0055965 , 0.3100000 ],
#####################################
[ 0.2544123 , -0.0194607 , 0.5460000 ],
#####################################
[ -0.0501188 , 0.0198800 , 0.5230000 ],
#####################################
[ -0.0311446 , 0.0255730 , 0.3250000 ],
#####################################
[ 0.0183357 , 0.0423574 , 0.3720000 ],
#####################################
[ -0.0592729 , 0.0795498 , 0.3520000 ],
#####################################
[ 0.0420416 , 0.0146144 , 0.4210000 ],
####################################
[ 0.0686175 , -0.0012115 , 0.3220000 ],
#####################################
[ 0.0622937 , -0.0238459 , 0.3590000 ],
#####################################
[ 0.1054679 , -0.0248103 , 0.4000000 ],
#####################################
[ 0.1080289 , -0.0011690 , 0.4390000 ],
#####################################
[ 0.0801068 , 0.0037272 , 0.3540000 ],
#####################################
[ 0.0970999 , -0.0092505 , 0.3310000 ],
#####################################
[ 0.0519485 , -0.0051572 , 0.5570000 ],
#####################################
[ 0.0860783 , 0.0378029 , 0.3320000 ],
####################################
[ 0.0547125 , 0.0283665 , 0.3460000 ],
####################################
        ])

        # gripper to object
        a2 = np.array([  # robot position
        # # 순 - 2



[-86.5094364  , 22.337069  , 147.18608176],
[-83.04730088,  60.8748803 , 193.6840057 ],
[-62.84915981,  62.19380698, 294.99169206],
[-42.73925463,  -7.57558187, 321.40728301],
[-99.25074779, -21.57214549 ,263.40541567],
[-114.91784918,   34.15678474 , 365.07589114],
[-115.16787766,   21.89976935 , 364.86096113],
[-102.39645112,   47.86442561 , 329.48738134],
[-66.94411639,   4.43714119 ,273.20759572],
[-88.7220767,   21.20324992 ,295.44882805],
[ -86.69431142, -150.56380826 , 294.96250102],
[-113.29445062 ,  29.37244621 , 223.45792951],
[-105.12350975 , 141.33852706 , 280.1114408 ],
[-131.76746425,  197.26082514 , 251.24238582],
[-111.40716143  ,103.5286468  , 131.43113092],
[-127.4496408 , -209.06244712 , 365.43174679],
[-86.01575593 , 94.41632296 ,340.09912465],
[-83.51306669 , 69.12734647 ,150.23111083],
[-68.02008873  ,12.60488784 ,196.07552456],
[-35.43799765 , 93.01814633 ,175.43930739],
[-87.09930489 , -7.15318072 ,234.28600192],
[-110.7069926  , -30.27309025 , 146.02195416],
[-125.21336867 , -25.50708175 , 175.94449377],
[-131.89799761,  -70.65783538 , 221.7247648 ],
[-104.9292294  , -72.45914289 , 255.56411706],
[-103.05273462 , -43.99804049 , 176.73136796],
[-115.8493799   ,-54.1628933  , 149.38098227],
[-114.50737671  , -8.23179899 , 371.55696422],
[-74.76544726, -46.2862368  ,155.46625608],
[-80.30923548 ,-12.08293456, 166.80806422],
        ])
        

        # 두 값 사이의 스케일을 맞춰줌
        # 카메라 단위(a1)는 m, gripper to object 단위는 mm 이므로 둘 사이의 단위를 맞춰 주기
        # 카메라의 값에 1000을 곱하는 것보다 gripper to object의 값에 1000을 나누는 것이 오차가 더 적다고 생각함
        a2 = a2/1000
        main = ICP()

        
        pcd_cam = o3d.geometry.PointCloud()
        pcd_cam.points = o3d.utility.Vector3dVector(a1) #ptList


        pcd_robot =o3d.geometry.PointCloud()
        pcd_robot.points = o3d.utility.Vector3dVector(a2) #List


        main.doICP(pcd_cam,pcd_robot)
        # main.cal_error(a1,a2)
        


if __name__ == '__main__':

    start = calibration()
    start.icp()